package edu.rit.csh.devin

import android.content.Context
import android.nfc.cardemulation.HostApduService
import android.os.Build
import android.os.Bundle
import androidx.annotation.RequiresApi
import org.spongycastle.util.io.pem.PemReader
import java.io.*
import java.security.KeyFactory
import java.security.Security
import java.security.Signature
import java.security.interfaces.ECPublicKey
import java.security.spec.X509EncodedKeySpec
import java.util.*
import javax.crypto.Cipher
import java.security.interfaces.RSAPublicKey


@RequiresApi(Build.VERSION_CODES.M)
class GatekeeperService: HostApduService() {
    companion object {
        val BASE_AID = byteArrayOf(0xF0.toByte(), 0x63, 0x73, 0x68, 0x72, 0x69, 0x74)
        const val NONCE_SIZE = 8
        init {
            Security.insertProviderAt(
                org.spongycastle.jce.provider.BouncyCastleProvider(),
                1
            )
        }
    }
    private var aidApplied = false
    private var state: HandshakeState = HandshakeState.SELECT

    enum class HandshakeState {
        READER_VERIFICATION,
        SUCCESS,
        SELECT,
    }

    enum class Realm(val id: String, private val slot: Int, private val publicKey: Int, private val asymmetricPublicKey: Int, var associationId: ByteArray) {
        DOORS("doors", 0, R.raw.doors, R.raw.doors_asymmetric, byteArrayOf(0, 1, 2, 3, 4)),
        DRINK("drink", 1, R.raw.drink, R.raw.drink_asymmetric, byteArrayOf(0, 1, 2, 3, 4)),
        MEMBER_PROJECTS("memberProjects", 2, R.raw.member_projects, R.raw.member_projects_asymmetric, byteArrayOf(0, 1, 2, 3, 4));
        companion object {
            fun fromAid(aid: ByteArray): Realm? {
                if (aid.size != BASE_AID.size) return null
                for (i in 0..(aid.size-2)) {
                    if (aid[i] != BASE_AID[i]) return null
                }
                val slotId = aid[aid.size-1]-BASE_AID[aid.size-1]
                return values().first { it.slot == slotId }
            }
        }
        fun getPublicKey(context: Context): ECPublicKey {
            val keyStr = context.resources.openRawResource(publicKey)
            val spki = PemReader(InputStreamReader(keyStr)).readPemObject()
            val key = KeyFactory.getInstance("ECDSA")
                .generatePublic(X509EncodedKeySpec(spki.content))
            return key as ECPublicKey
        }
        fun getPublicAsymmetricKey(context: Context): RSAPublicKey {
            val keyStr = context.resources.openRawResource(asymmetricPublicKey)
            val spki = PemReader(InputStreamReader(keyStr)).readPemObject()
            val key = KeyFactory.getInstance("RSA")
                .generatePublic(X509EncodedKeySpec(spki.content))
            return key as RSAPublicKey
        }
    }

    /** Nonce generated by us */
    private val ourNonce: ByteArray = ByteArray(8)
    private val random = Random()
    private var realm: Realm = Realm.MEMBER_PROJECTS

    /**
     *
     * This method will be called when a command APDU has been received
     * from a remote device. A response APDU can be provided directly
     * by returning a byte-array in this method. Note that in general
     * response APDUs must be sent as quickly as possible, given the fact
     * that the user is likely holding their device over an NFC reader
     * when this method is called.
     *
     *
     * If there are multiple services that have registered for the same
     * AIDs in their meta-data entry, you will only get called if the user has
     * explicitly selected your service, either as a default or just for the next tap.
     *
     *
     * This method is running on the main thread of your application.
     * If you cannot return a response APDU immediately, return null
     * and use the [.sendResponseApdu] method later.
     *
     * @param commandApdu The APDU that was received from the remote device
     * @param extras A bundle containing extra data. May be null.
     * @return a byte-array containing the response APDU, or null if no
     * response APDU can be sent at this point.
     */
    override fun processCommandApdu(commandApdu: ByteArray?, extras: Bundle?): ByteArray? {
        if (!aidApplied) {
            NFCChannel(this).applyAids()
            aidApplied = true
        }
        if (commandApdu == null) return null
        val apdu = APDU(commandApdu)
        if (apdu.instructionId == 0xA4.toByte()) {
            state = HandshakeState.SELECT
        }
        return when (state) {
            HandshakeState.SELECT -> {
                if (apdu.instructionId != 0xA4.toByte() || apdu.p1 != 0x04.toByte() || apdu.p2 != 0x00.toByte()) {
                    println("Wrong select?")
                    return null
                }
                // println(apdu.data.map { value -> value.toString(16).padStart(2, '0') })
                if (apdu.data.size != BASE_AID.size) {
                    println("Wrong size?")
                    return null
                }
                this.realm = Realm.fromAid(apdu.data) ?: return null
                this.random.nextBytes(this.ourNonce)
                this.state = HandshakeState.READER_VERIFICATION
                println("OK! Sending our nonce back!!!!")
                val bytes = NFCResponse(this.ourNonce, 0x9000U).toBytes()
                println(bytes.map { value -> value.toUByte().toString(16).padStart(2, '0') })
                bytes
            }
            HandshakeState.READER_VERIFICATION -> {
                println("Reader nonce is valid?")

                // Validate signature
                val publicKey = realm.getPublicKey(this.applicationContext)
                val signer = Signature.getInstance("SHA384withECDSA")
                signer.initVerify(publicKey)
                val theirNonce =
                    apdu.data.slice(IntRange(apdu.data.size - NONCE_SIZE, apdu.data.size - 1))
                signer.update(ourNonce + theirNonce)
                val isValid = signer.verify(apdu.data, 0, apdu.data.size-NONCE_SIZE)
                println("Okay, are we valid? $isValid")
                if (!isValid) {
                    this.state = HandshakeState.SELECT
                    return null
                }
                println("Looks like it's valid!!")

                assert(theirNonce.size == NONCE_SIZE)
                val encodedValue = this.realm.associationId + theirNonce

                val publicAsymmetricKey = realm.getPublicAsymmetricKey(this.applicationContext)
                val cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding")
                cipher.init(Cipher.ENCRYPT_MODE, publicAsymmetricKey)
                val encryptedValue = cipher.doFinal(encodedValue)
                // Send back encrypted `readerNonce` + association ID
                this.state = HandshakeState.SUCCESS
                NFCResponse(encryptedValue, 0x9069U).toBytes()
            }
            HandshakeState.SUCCESS -> {
                // Show a message to the user
                println("Success from reader!")
                null
            }
        }
    }

    /**
     * This method will be called in two possible scenarios:
     *  * The NFC link has been deactivated or lost
     *  * A different AID has been selected and was resolved to a different
     * service component
     * @param reason Either [.DEACTIVATION_LINK_LOSS] or [.DEACTIVATION_DESELECTED]
     */
    override fun onDeactivated(reason: Int) {
        println("Deactivated!!!")
        this.state = HandshakeState.SELECT
    }
}